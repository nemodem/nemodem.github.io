<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于Myeclipse2017 MemoryAnalyzer的安装</title>
    <url>/2025/08/06/MAT_Install/</url>
    <content><![CDATA[<p>最近想要安装MemoryAnalyzer（MAT）这个性能分析工具的插件，本以为网上教程那么多，教我一个技术一般的人足够了，我安装的是Myeclipse2017，可是在网上翻了一圈，大多数的Myeclipse教程都是10版本的，我呢，不想在论坛上问（没耐心…）,突然想到了自己当初装svn插件时的事情，类比一下是不是也可以呢？步骤如下：</p>
<span id="more"></span>

<p>首先下载MemoryAnalyzer插件（这个一样）<br><a href="http://www.eclipse.org/mat/downloads.php">http://www.eclipse.org/mat/do...</a><br>点击Archived Update Site后面的压缩包</p>
<img src="/2025/08/06/MAT_Install/bVbczqP.webp" class="" title="说明">

<p>解压之后如图：</p>
<img src="/2025/08/06/MAT_Install/bVbczrl.webp" class="" title="说明">
<p>将feature与binary中的文件拷入myeclipse的feature中，将plugins中的文件拷入myeclipse的plugins中，然后<br>重启myeclipse<br>如下图</p>
<img src="/2025/08/06/MAT_Install/bVbczrP.webp" class="" title="说明">
<p>表示安装成功。<br>进入windows-preference中可以看到MemoryAnalyzer</p>
]]></content>
      <categories>
        <category>工具与组件</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>内存分析</tag>
      </tags>
  </entry>
  <entry>
    <title>MemoryAnalyzer补充</title>
    <url>/2025/08/06/MAT_complement/</url>
    <content><![CDATA[<p><strong>首先</strong>，之前在网上下载的是Myeclipse的插件 –memory analyzer，在网站的下面是Memory Analyzer的单机版，单机版安装简单，适合日常操作。下载地址：<a href="http://www.eclipse.org/mat/downloads.php">http://www.eclipse.org/mat/do...</a><br>之前一直纠结如何获取一个Java项目的内存分析的hprof文件，网上找了很多博客都是一笔带过（这个很容易？！），最后可能是搜索恰当,用JVM指令:</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=文件名.hprof[pid]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>导出内存信息文件，然后利用Memory Analyzer工具打开进行内存分析（对于内存泄露，OOM等分析有很大的帮助）。</p>
<h2 id="分析三步曲"><a href="#分析三步曲" class="headerlink" title="分析三步曲"></a><strong>分析三步曲</strong></h2><p>通常我们都会采用下面的“三步曲”来分析内存泄露问题：</p>
<ul>
<li>首先，对问题发生时刻的系统内存状态获取一个整体印象。</li>
<li>第二步，找到最有可能导致内存泄露的元凶，通常也就是消耗内存最多的对象</li>
<li>接下来，进一步去查看这个内存消耗大户的具体情况，看看是否有什么异常的行为。</li>
</ul>
<p>下面将用一个基本的例子来展示如何采用“三步曲”来查看生产的分析报告。</p>
<h2 id="查看报告之一：内存消耗的整体状况"><a href="#查看报告之一：内存消耗的整体状况" class="headerlink" title="查看报告之一：内存消耗的整体状况"></a>查看报告之一：内存消耗的整体状况</h2><p>图 7. 内存泄露分析报告</p>
<img src="/2025/08/06/MAT_complement/bVbcR3y.webp" class="" title="说明">

<p>如图 7 所示，在报告上最醒目的就是一张简洁明了的饼图，从图上我们可以清晰地看到一个可疑对象消耗了系统 99% 的内存。在图的下方还有对这个可疑对象的进一步描述。我们可以看到内存是由<strong>java.util.Vectorcom.ibm.oti.vm.BootstrapClassLoader</strong> 负责这个对象的加载。这段描述非常短，但我相信您已经可以从中找到很多线索了，比如是哪个类占用了绝大多数的内存，它属于哪个组件等等。<br>接下来，我们应该进一步去分析问题，为什么一个 Vector 会占据了系统 99% 的内存，谁阻止了垃圾回收机制对它的回收。</p>
<h2 id="查看报告之二：分析问题的所在"><a href="#查看报告之二：分析问题的所在" class="headerlink" title="查看报告之二：分析问题的所在"></a>查看报告之二：分析问题的所在</h2><p>首先我们简单回顾下 JAVA 的内存回收机制，内存空间中垃圾回收的工作由垃圾回收器 (<strong>Garbage Collector,GC</strong>) 完成的，它的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象，反之，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配。<br>在垃圾回收机制中有一组元素被称为根元素集合，它们是一组被虚拟机直接引用的对象，比如，正在运行的线程对象，系统调用栈里面的对象以及被 <strong>system class loader</strong> 所加载的那些对象。堆空间中的每个对象都是由一个根元素为起点被层层调用的。因此，一个对象还被某一个存活的根元素所引用，就会被认为是存活对象，不能被回收，进行内存释放。因此，我们可以通过分析一个对象到根元素的引用路径来分析为什么该对象不能被顺利回收。如果说一个对象已经不被任何程序逻辑所需要但是还存在被根元素引用的情况，我们可以说这里存在内存泄露。<br>现在，让我们开始真正的寻找内存泄露之旅，点击“Details ”链接，可以看到如图 8 所示对可疑对象 1 的详细分析报告。<br>图 8. 可疑对象 1 的详细分析报告</p>
<img src="/2025/08/06/MAT_complement/bVbcR3L.webp" class="" title="说明">

<p>我们查看下从 GC 根元素到内存消耗聚集点的最短路径：<br>图 9. 从根元素到内存消耗聚集点的最短路径</p>
<img src="/2025/08/06/MAT_complement/bVbcR3V.webp" class="" title="说明">

<p>我们可以很清楚的看到整个引用链，内存聚集点是一个拥有大量对象的集合，如果你对代码比较熟悉的话，相信这些信息应该能给你提供一些找到内存泄露的思路了。<br>接下来，我们再继续看看，这个对象集合里到底存放了什么，为什么会消耗掉如此多的内存。<br>图 10. 内存消耗聚集对象信息</p>
<img src="/2025/08/06/MAT_complement/bVbcR34.webp" class="" title="说明">

<p>在这张图上，我们可以清楚的看到，这个对象集合中保存了大量 Person 对象的引用，就是它导致的内存泄露。<br>至此，我们已经拥有了足够的信息去寻找泄露点，回到代码，我们发现，是下面的代码导致了内存泄露 :<br>清单 1. 内存泄漏的代码段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (1&lt;2) </span><br><span class="line">&#123; </span><br><span class="line">            </span><br><span class="line">    Person person = new Person(&quot;name&quot;,&quot;address&quot;,i); </span><br><span class="line">    v.add(person); </span><br><span class="line">    person = null; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>从上面的例子我们可以看到用 MAT 来进行堆转储文件分析，寻找内存泄露非常简单，尤其是对于新手而言，这是一个很好的辅助分析工具。但是，MAT 绝对不仅仅是一个“傻瓜式”内存分析工具，它还提供很多高级功能，比如 MAT 支持用 **OQL（Object Query Language）**对 <strong>heap dump</strong> 中的对象进行查询，支持对线程的分析等，有关这些功能的使用可以参考 MAT 的帮助文档。</p>
]]></content>
      <categories>
        <category>工具与组件</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>内存分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/08/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>分布式之数据库和缓存双写一致性方案解析（摘录）</title>
    <url>/2025/08/06/cacheAndMysql_consistency/</url>
    <content><![CDATA[<p><strong>引言</strong></p>
<p><strong>为什么写这篇文章？</strong></p>
<p>首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。</p>
<span id="more"></span>

<p>​        <img src="/2025/08/06/cacheAndMysql_consistency/1.png" class="" title="说明"></p>
<p>但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。目前没有一篇全面的博客，对这几种方案进行解析。于是博主战战兢兢，顶着被大家喷的风险，写了这篇文章。</p>
<p><strong>文章结构</strong></p>
<p>本文由以下三个部分组成<br>1、讲解缓存更新策略<br>2、对每种策略进行缺点分析<br>3、针对缺点给出改进方案</p>
<p><strong>正文</strong></p>
<p>先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。<br>在这里，我们讨论<strong>三种</strong>更新策略：</p>
<ol>
<li><p>先更新数据库，再更新缓存</p>
</li>
<li><p>先删除缓存，再更新数据库</p>
</li>
<li><p>先更新数据库，再删除缓存</p>
</li>
</ol>
<p>应该没人问我，为什么没有先更新缓存，再更新数据库这种策略。</p>
<p><strong>(1)</strong> <strong>先更新数据库，再更新缓存</strong></p>
<p>这套方案，大家是普遍反对的。为什么呢？有如下两点原因。<br><strong>原因一（线程安全角度）</strong><br>同时有请求A和请求B进行更新操作，那么会出现<br>（1）线程A更新了数据库<br>（2）线程B更新了数据库<br>（3）线程B更新了缓存<br>（4）线程A更新了缓存<br>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。<br><strong>原因二（业务场景角度）</strong><br>有如下两点：<br>（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。<br>（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。</p>
<p>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。</p>
<p><strong>(2)</strong> <strong>先删缓存，再更新数据库</strong></p>
<p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>那么，<strong>如何解决呢？</strong> <strong>采用延时双删策略</strong><br>伪代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void write(String key,Object data)&#123;</span><br><span class="line">	redis.delKey(key);</span><br><span class="line"> 	db.updateData(data);</span><br><span class="line">	Thread.sleep(1000);</span><br><span class="line">	redis.delKey(key);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>转化为中文描述就是<br>（1）先淘汰缓存<br>（2）再写数据库（这两步和原来一样）<br>（3）休眠1秒，再次淘汰缓存<br>这么做，可以将1秒内所造成的缓存脏数据，再次删除。<br><strong>那么，这个1秒怎么确定的，具体该休眠多久呢？</strong><br>针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。<br><strong>如果你用了mysql的读写分离架构怎么办？</strong><br>ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。<br>（1）请求A进行写操作，删除缓存<br>（2）请求A将数据写入数据库了，<br>（3）请求B查询缓存发现，缓存没有值<br>（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值<br>（5）请求B将旧值写入缓存<br>（6）数据库完成主从同步，从库变为新值<br>上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。<br><strong>采用这种同步淘汰策略，吞吐量降低怎么办？</strong><br>ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。<br><strong>第二次删除,如果删除失败怎么办？</strong><br>这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>（6）请求A试图去删除请求B写入对缓存值，结果失败了。<br>ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。<br><strong>如何解决呢？</strong><br>具体解决方案，且看博主对第(3)种更新策略的解析。</p>
<p><strong>(3)</strong> <strong>先更新数据库，再删缓存</strong></p>
<p>首先，先说一下。老外提出了一个缓存更新套路，名为<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">《Cache-Asidepattern》</a>。其中就指出</p>
<p>·       <strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</p>
<p>·       <strong>命中</strong>：应用程序从cache中取数据，取到后返回。</p>
<p>·       <strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</p>
<p>另外，知名社交网站facebook也在论文</p>
<p><a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">《ScalingMemcache at Facebook》</a></p>
<p>中提出，他们用的也是先更新数据库，再删缓存的策略。</p>
<p>这种情况不存在并发问题么？</p>
<p>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生<br>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存<br>ok，如果发生上述情况，确实是会发生脏数据。</p>
<p>然而，发生这种情况的概率又有多少呢？</p>
<p>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。<br>假设，有人非要抬杠，有强迫症，一定要解决怎么办？</p>
<p>如何解决上述并发问题？</p>
<p>首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。</p>
<p>还有其他造成不一致的原因么？</p>
<p>有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。</p>
<p>如何解决？</p>
<p>提供一个保障的重试机制即可，这里给出两套方案。</p>
<p> <strong>方案一</strong>：</p>
<p>如下图所示：</p>
 <img src="/2025/08/06/cacheAndMysql_consistency/2.png" class="" title="说明">

<p>流程如下所示</p>
<p>（1）更新数据库数据；</p>
<p>（2）缓存因为种种问题删除失败</p>
<p>（3）将需要删除的key发送至消息队列</p>
<p>（4）自己消费消息，获得需要删除的key</p>
<p>（5）继续重试删除操作，直到成功</p>
<p>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p>
<p><strong>方案二</strong>：</p>
<img src="/2025/08/06/cacheAndMysql_consistency/3.png" class="" title="说明">

<p>流程如下图所示：<br>（1）更新数据库数据<br>（2）数据库会将操作信息写入binlog日志当中<br>（3）订阅程序提取出所需要的数据以及key<br>（4）另起一段非业务代码，获得该信息<br>（5）尝试删除缓存操作，发现删除失败<br>（6）将这些信息发送至消息队列<br>（7）重新从消息队列中获得该数据，重试操作。</p>
<p>**备注说明：**上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。</p>
<p><strong>总结</strong></p>
<p>本文其实是对目前互联网中已有的一致性方案，进行了一个总结。对于先删缓存，再更新数据库的更新策略，还有方案提出维护一个内存队列的方式，博主看了一下，觉得实现异常复杂，没有必要，因此没有必要在文中给出。最后，希望大家有所收获。</p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>openldap安装</title>
    <url>/2025/08/06/openldap%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><strong>轻型目录访问协议</strong>（英文：Lightweight Directory Access Protocol，缩写：LDAP）是一个开放的，中立的，工业标准的应用协议，通过IP协议提供访问控制和维护分布式信息的目录信息。<br>OpenLDAP是轻型目录访问协议（Lightweight Directory Access Protocol，LDAP）的自由和开源的实现，在其OpenLDAP许可证下发行，并已经被包含在众多流行的Linux发行版中。</p>
<span id="more"></span>

<p><strong>可以这样讲</strong>：市面上只要你能够想像得到的所有工具软件，全部都支持LDAP协议。比如说你公司要安装一个项目管理工具，那么这个工具几乎必然支持LDAP协议，你公司要安装一个bug管理工具，这工具必然也支持LDAP协议，你公司要安装一套软件版本管理工具，这工具也必然支持LDAP协议。LDAP协议的好处就是你公司的所有员工在所有这些工具里共享同一套用户名和密码，来人的时候新增一个用户就能自动访问所有系统，走人的时候一键删除就取消了他对所有系统的访问权限，这就是LDAP。</p>
<hr>
<p>这几天由于项目需要，经理让我研究一下openldap,写一个连接openldap以及实现与openldap数据交互的SDK。之前从来没有接触过openldap,所以我想从安装做起，做一个记录，不多说了，下面是步骤：<br>我用的是银河麒麟系统，内核是ubuntu的,首先要将用户转为root权限,下面开始安装。</p>
<h2 id="1、安装openssl"><a href="#1、安装openssl" class="headerlink" title="1、安装openssl"></a>1、安装openssl</h2><p>安装openldap前提是已经安装好openssl和BerkeleyDB,我们先来安装openssl(这个虽然系统自带，但是最好不要卸载，重新安装一个，卸载之后很多服务可能起不来)<br>下载地址：<a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a><br>之后解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf +压缩包名</span><br></pre></td></tr></table></figure>

<p>进入文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 文件名</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./config shared  #注意这里是用./config 会安装到/usr/local/ssl</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置库文件搜索路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;/usr/local/ssl/lib&quot; &gt;&gt; /etc/ld.so.conf</span><br><span class="line"></span><br><span class="line">ldconfig -V</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这2句的作用就是通知系统Berkeley DB的动态链接库在&#x2F;usr&#x2F;local&#x2F;berkeleydb&#x2F;lib&#x2F;目录。</p>
<ul>
<li><strong>配置&#x2F;etc&#x2F;ld.so.conf文件</strong></li>
</ul>
<p>ld.so.conf文件配置了需要读入告诉缓存中的动态函数库所在目录 重新配置ld.so.conf后，在命令行执行ldconfig命令生效该软件默认是安装在&#x2F;usr&#x2F;local&#x2F;BerkeleyDB.4.2目录下。安装完成后，要把&#x2F;usr&#x2F;local&#x2F;BerkeleyDB.4.2&#x2F;lib的库路径加到&#x2F;etc&#x2F;ld.so.conf文件内，添加完成后执行一次ldconfig，使配置文件生效。这样编译openldap时才能找到相应的库文件。</p>
<ul>
<li><strong>ld.so.conf是什么东西？</strong></li>
</ul>
<p>它就是系统动态链接库的配置文件。此文件内,存放着可被LINUX共享的动态链接库所在目录的名字(系统目录&#x2F;lib,&#x2F;usr&#x2F;lib除外)，各个目录名间以空白字符(空格，换行等)或冒号或逗号分隔。一般的LINUX发行版中，此文件均含一个共享目录&#x2F;usr&#x2F;X11R6&#x2F;lib，为X window窗口系统的动态链接库所在的目录。 ldconfig是它的管理命令，具体操作方法可查询man手册</p>
<ul>
<li><strong>ldconfig是什么</strong></li>
</ul>
<p>它是一个程序，通常它位于&#x2F;sbin下，是root用户使用的东东。具体作用及用法可以man ldconfig查到<br>简单的说，它的作用就是将&#x2F;etc&#x2F;ld.so.conf列出的路径下的库文件 缓存到&#x2F;etc&#x2F;ld.so.cache 以供使用<br>因此当安装完一些库文件，(例如刚安装好glib)，或者修改ld.so.conf增加新的库路径后，需要运行一下&#x2F;sbin&#x2F;ldconfig<br>使所有的库文件都被缓存到ld.so.cache中，如果没做，即使库文件明明就在&#x2F;usr&#x2F;lib下的，也是不会被使用的，结果编译过程中抱错，缺少xxx库，去查看发现明明就在那放着……</p>
<h2 id="2、安装BerkeleyDB"><a href="#2、安装BerkeleyDB" class="headerlink" title="2、安装BerkeleyDB"></a>2、安装BerkeleyDB</h2><p>下载地址： <a href="http://www.oracle.com/technetwork/database/databasetechnologies/berkeleydb/downloads/index-082944.html">http://www.oracle.com/technet...</a>（注意要根据openldap的README文件中的内容下载合适的版本下面是一段原文，在下载时一定要注意！）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SLAPD:</span><br><span class="line">            BDB and HDB backends require Oracle Berkeley DB 4.4 - 4.8,</span><br><span class="line">            or 5.0 - 5.1.  It is highly recommended to apply the</span><br><span class="line">            patches from Oracle for a given release.</span><br></pre></td></tr></table></figure>

<p>之后执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf +压缩包名</span><br><span class="line">cd 文件名</span><br><span class="line">cd build_unix</span><br><span class="line">../dist/configure --prefix=/usr/local/berkeleydb --enable-cxx  #其中–enable-cxx就是编译C++库，这样才能编译Berkeley DB数据库的PHP扩展php_db4。</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">echo &#x27;/usr/local/berkeleydb/lib/&#x27; &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig #添加完成后执行一次ldconfig，使配置文件生效。这样编译openldap时才能找到相应的库文件。</span><br><span class="line">ldconfig -V</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3、安装openldap"><a href="#3、安装openldap" class="headerlink" title="3、安装openldap"></a>3、安装openldap</h2><p>终于进入正题，下载地址：<a href="http://www.openldap.org/software/download/">http://www.openldap.org/softw...</a><br>之后执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf +压缩包名</span><br><span class="line">cd 文件名</span><br><span class="line">env CPPFLAGS=&quot;-I/usr/local/berkeleydb/include&quot; LDFLAGS=&quot;-L/usr/local/berkeleydb/lib&quot; LD_LIBRARY_PATH=&quot;/usr/local/berkeleydb/lib&quot;  ./configure --prefix=/usr/local/openldap --enable-ldbm --enable-overlays --enable-ldap --enable-accesslog  --enable-syncprov   </span><br></pre></td></tr></table></figure>

<p><strong>注意以上配置语句，要设置资料库的include和lib路径，否则在配置到资料库相关内容时会提示Berkeley DB版本不兼容，并中断配置。如果没有–enable-ldbm选项，在make test时会提示ldbm找不到。为了减少出错，还是加上为好。后面的几个参数是为了使用openldap的同步协议，必须在编译阶段强制开启如下的编译选项，其中-enable-ldap 选项用于支持ldap代理，在同步中用来推送数据；–enable-accesslog 选项用于记录用户操作，在同步中用于记录服务端的数据修改；–enable-syncprov 选项用于支持数据同步引擎。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make depend</span><br><span class="line">make</span><br><span class="line">make test # (在make test阶段要花费较长时间进行测试，好像有16项吧。可以放在那里等，自己做其他事情，不过成与不成就看这下的了，如果没问题就可安装了)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>配置库文件搜索路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;/usr/local/openldap/lib&quot; &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig -V</span><br></pre></td></tr></table></figure>

<p>说说这里的坑吧，第一次装这个东西，网上的资料要么对新人不太友好，要么就是过时的资料，还有就是本身就是错误的，总之安装挺不容易的，我具体说说吧，一个就是刚才我写到的，之前装的BerkeleyDB版本太高，导致在装openldap时提示BerkeleyDB不可用，后来装了适合的版本，又提示版本不匹配，google后在*.&#x2F;configure*之前添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LD_LIBRARY_PATH=&quot;/usr/local/berkeleydb/lib&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好不容易可以执行下一步了，在make test 时又测试失败，原来动态连接库出问题了，没有设置正确，导致运行时的库文件没能找到,所以要检查环境变量.LD_LIBRARY_PATH中一定要有系统的以及bdb的环境库文件位置.之前可能直接复制的，没有看路径导致的错误……总之“惊喜”不断，不过最后还是安装成功了，先喘口气，后面还有更大的考验……</p>
<h2 id="补充：linux源码安装的三步曲"><a href="#补充：linux源码安装的三步曲" class="headerlink" title="补充：linux源码安装的三步曲"></a>补充：linux源码安装的三步曲</h2><p>从源码安装程序时,需要依此执行以下步骤:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">他们的含义:</span><br></pre></td></tr></table></figure>

<p>这些都是典型的使用GNU的AUTOCONF和AUTOMAKE产生的程序的安装步骤。<br>.&#x2F;configure是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本<br>make是用来编译的，它从Makefile中读取指令，然后编译。<br>make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p>
]]></content>
      <categories>
        <category>工具与组件</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>项目的一点总结</title>
    <url>/2025/08/06/%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>项目名称：后勤保障指挥系统<br>项目部署环境：银河麒麟系统+myEclipse+mySql5.6+tomcat7+rabbitmq+基于ssm的公司框架+sip协议<br>启动方式：<br>        启功sip服务器：cd &#x2F;home&#x2F;wisdom&#x2F;build_mpms&#x2F;bin,.&#x2F;start.sh脚本一键全启，第一次开启需要chmod +x +脚本&#x2F;文件名称 进行授权。</p>
<span id="more"></span>

<p>​         需要对cd &#x2F;home&#x2F;wisdom&#x2F;build_mpms&#x2F;bin路径中的配置文件进行配置，将所有.ini 文件中的ip地址改成你要连接的服务器的地址，注意解除级联时的count&#x3D;0.<br>​        打开sc.log日志：tail -f &#x2F;tmp&#x2F;sc.log打开日志，里面有注册的信息（绿色字体)。<br>​        </p>
<pre><code>    启动rabbitmq: cd /usr/local/rabbitmq-3.5.2/sbin,运行./rabbitmq-server -detached
                   ps -ef|grep rabbitmq 观察是否有rabbitmq进程。
    启动mysql:cd /usr/local/mysql/bin,当前路径下运行./mysqld_safe &amp;文件，符号代表后台运行。
    启动服务：cd /usr/local/JavaApp/wd_msg_center/ 运行./run.sh debug
             cd /usr/local/JavaApp/wd_mw_dal (data-access). ./run.sh debug
             cd /usr/local/JavaApp/wd_svc_resource (source-dir) ./run.sh debug
             cd /usr/local/JavaApp/wd_svc_authz (auth-service) ./run.sh debug
             cd /usr/local/JavaApp/wd_svc_session (session-manager) ./run.sh debug
             cd /usr/local/JavaApp/wd_agent_sip (sip-agent) ./run.sh debug
             cd /usr/local/tomcat/bin  当前路径下运行./catalina.sh run
             
             这段是调试时使用，真正部署时后台启动就可以了。
</code></pre>
<p> 进入网址，http:&#x2F;&#x2F; +ip地址   如果tomcat启动成功，可以看到登陆界面，更改服务资源与当前服务节点（与你连接的服务器ip保持一致）<br>  如果一切顺利，安装技保终端，安装vs2015补丁就可以登陆了，（windows10安装补丁有错误，害我重新装的系统）<br>  注意银河麒麟桥接模式，需要用户与服务器都要在同一个ip频段才能去连接。<br>  我负责的是系统中的指挥业务模块，包括指挥组管理，指挥呼叫，临时添加非指挥组成员（在指挥过程中，下同），强退指挥组成员，指挥提醒，暂停指挥，专向指挥，协同指挥，授权指挥，接替指挥，越级指挥，临时指挥，呼叫组外人员，设置组播，调阅视频等等。<br>  说说我个人觉得的技术难点以及“坑”：首先的难点在于对业务流程的理解，比如接替指挥，授权指挥，因为指挥组的成员结构是我缓存中的数据，因此在业务发起后的成员结构是怎样的构成需要慢慢理解（文档上的用语太书面，理解时半猜半懂的，需要及时的沟通）。<br>  在理解业务后，编写的过程中要随时考虑系统的状态，以及你的缓存变化，还有接收通知或发送通知后的变化，任何的变化都有可能是你模块中的bug,如果你没有考虑的话。例如强退成员时，我们是将这个成员的某个状态字段更改，而不是直接将这个成员从这个缓存中删除，因此，在停止指挥时，我们要恢复原来的成员结构，被强退的成员需要在他的用户列表中看到原来的他所在的指挥组，这时在判断时（我需要与数据库中的原表比较，判断这个成员是增加的还是减少的）需要判断成员的状态，如果状态是剔除状态，要重新把他放入一个集合中，通过处理判断当前用户是否是原指挥组成员，是的就要在当前用户列表中显示这个组，不是就要删除这个组信息。<br>    一、<br>    for(SimpleUser simpleUser:members){<br>                &#x2F;&#x2F;表示删除的成员状态<br>    			if(!”2”.equals(simpleUser.getBizStatus())){<br>    				simpleIdList.add(simpleUser.getId());<br>    			}</p>
<pre><code>二、
//求差集，这不重要			
changedIdList.addAll(memberIdsByData);
changedIdList.retainAll(simpleIdList);
memberIdsByData.removeAll(changedIdList);
if(memberIdsByData.size() != 0)&#123;
	for(String memberId:memberIdsByData)&#123;
        //在缓存中添加组信息
		addGroupCache(memberId, groupWithMembers);
	&#125;
&#125;
simpleIdList.removeAll(changedIdList);
if(simpleIdList.size() != 0)&#123;
	for(String memberId:simpleIdList)&#123;
        //删除这个缓存中的这个组信息
		deleteGroupCache(memberId, directGroup.getId());
	&#125;
&#125;
</code></pre>
<p>  还有缓存的维护虽然没什么难点，但是逻辑要清晰，细节很重要，否则有的bug真的欲仙欲死，debug时那叫一个酸爽……<br>  有一个坑我印象很深刻，因为那天第三方测试，忙了一宿，系统的服务都已部署在生产环境中，大家都很紧张，偏偏我的业务（就是那个强退成员）无法实现，报了异常（json转换异常，很奇怪）可是我们自测时在本地运行时业务是没有问题的，我又加了一夜的班（悲催），找到原因，由于之前的一个接口没有用上，但考虑以后扩展，就一直没有注释掉，偏偏它的uri地址与强退成员接口的uri一模一样，导致在生产环境中根本没有扫描到我的强退成员接口，报异常也就不奇怪了。在我注释掉那个扩展接口后，系统正常。<br>  <em>再说说这个项目的动态信息同步以及静态信息同步策略，先说动态信息同步，动态信息同步采用订阅-发布级联模型实现，在SIP标准规范上，PUBLISH和SUBSCRIBE&#x2F;NOTIFY为两种不同的事务，在动态信息同步中必须依据订阅-发布级联模型的时序图实现，需先SUBSCRIBE订阅，后续才使用PUBLISH事务。在此项目中，第一次订阅的节点需全量同步（NOTIFY和PUBLISH均全量），后续均增量同步（NOTIFY和PUBLISH均增量）。静态信息同步（路由信息同步）使用LDAP,即静态信息管理（LDAP）中节点信息可实现路由信息同步，生成全局路由表且支持更新。</em><br>  总之，这个项目比较大，我还是很庆幸能有这样的机会去参加这样的项目，这个项目技术不算新，但是很考验个人的基础知识以及对细节的把握，同时与众多不同领域的程序员对接程序让我对整个系统有了全面的了解，纠正了很多之前的不规范的编程习惯，先写这么多，有补充还会继续更新。<br>​<br>​        </p>
]]></content>
      <categories>
        <category>项目心得</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>linux</tag>
        <tag>ssm</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客设置以及Next主题美化</title>
    <url>/2025/08/06/hexo/</url>
    <content><![CDATA[<h2 id="1-blog配置"><a href="#1-blog配置" class="headerlink" title="1. blog配置"></a>1. blog配置</h2><p><del>常言道：</del></p>
<blockquote>
<p>任何不谈配置只谈操作的行为都是在耍流氓 –佚名</p>
</blockquote>
<p>虽说hexo的版本3.x之间改动也不是很大，next5.x系列和现在的6.x系列也差不多，但是终归还是有那么一点细小的变化，保不准就会有bug生成，所以博主还是提一下自己的blog配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hexo v3.7.1     Next v6.3.0   编辑器：sublime text2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就目前为止，已经算是挺新版的了，当然，大多数配置各版本之间都一样，大家可以酌情考虑版本的选择。</p>
<span id="more"></span>

<p><strong>好了！准备进入正题！本blog将带领各位怎么将一个空空如也的blog装饰成博主一样有那么一点起色的网站。博主将从零搭起，所有的操作都将在博主的笔记本上为大家做出示范。</strong></p>
<h3 id="1-1-next主题基本配置"><a href="#1-1-next主题基本配置" class="headerlink" title="1.1 next主题基本配置"></a>1.1 next主题基本配置</h3><p>首先我们先下载<a href="https://github.com/theme-next/hexo-theme-next/releases">next主题:</a>在这里选择大家需要的版本进行下载。下载完成后，我们的blog便有了两个主要的配置文件，分别是hexo自带的<code>_config.yml</code>文件和next主题自带的<code>_config.yml</code>文件，为了方便，我们将hexo自带的<code>_config.yml</code>文件称为站点配置文件，next主题带的<code>_config.yml</code>文件称为主题配置文件。</p>
<p>首先，第一步我们来更换一下blog的主题，这一步又分为三个小步骤：</p>
<ol>
<li><p>将下载下来的next主题文件夹重命名为 next 。</p>
</li>
<li><p>将next文件夹移入blog所在的文件夹的themes 文件夹中，在这里，本人是<code>/blog/themes</code></p>
</li>
<li><p>修改站点配置文件，在配置文件中搜索</p>
<p>theme</p>
<p>，将其的值改为</p>
<p>next</p>
<p>。</p>
<p>注意 冒号： 后面一定要有一个空格</p>
<p>&#x2F;&#x2F; 站点_config.yml 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>现在主题就已经配置好了，接下来我们优化一下：继续修改站点配置文件：<br>&#x2F;&#x2F; 站点_config.yml 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Eternal_zttz #网站的名字</span><br><span class="line">subtitle: Saty Hungry，Stay Foolish #网站的副标题</span><br><span class="line">description: 个人blog网站 #个人的描述</span><br><span class="line">keywords:</span><br><span class="line">author: Eternal_zttz #博主的名字</span><br><span class="line">language: zh-CN #blog的语言  zh-CN 代表中文</span><br><span class="line">timezone:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们修改主题配置文件：<br>&#x2F;&#x2F; 主题_config.yml 文件 ，搜索Schemes可找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">scheme: Pisces</span><br><span class="line">#scheme: Gemini</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是next的基本页面布局，默认为Muse布局，在这里，我们选择第三个Pisces</p>
<p>很好，接下来，我们在终端命令行cd 进入blog所在目录，如我是直接命名为blog，所以<code>cd blog</code>:</p>
<p>接着运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在浏览器中打开链接：不出意外，打开后会是这么样的界面：<br><img src="http://pfv94oich.bkt.clouddn.com/webtest.png" alt="blog"><br>ok，我们的blog已经略有起色，样式已经离我们的最终样式八九不离十了，接下来，我们将对其的各个部分进行优化：</p>
<hr>
<h2 id="2-next主题侧边栏优化"><a href="#2-next主题侧边栏优化" class="headerlink" title="2. next主题侧边栏优化"></a>2. next主题侧边栏优化</h2><p>在这一部分，我们将对next主题的侧边栏进行优化，主要分为以下几部分：</p>
<ol>
<li>next主题页面生成</li>
<li>个人头像设置</li>
<li>点击个人头像回到主页面</li>
<li>RSS订阅设置</li>
<li>社交栏图标的设置</li>
<li>添加网易云音乐</li>
<li>页面圆角的设置</li>
</ol>
<h3 id="2-1-next主题页面生成"><a href="#2-1-next主题页面生成" class="headerlink" title="2.1. next主题页面生成"></a>2.1. next主题页面生成</h3><p>我们可以看到，hexo默认生成的页面只有两个，即<strong>首页</strong>和<strong>归档</strong> 页面，对于有强迫症的我来说简直是<strong>不！</strong> <strong>协！</strong> <strong>！调</strong>，那么接下来，我们来生成我们所需的页面：</p>
<h4 id="2-1-1-页面的生成："><a href="#2-1-1-页面的生成：" class="headerlink" title="2.1.1 页面的生成："></a>2.1.1 页面的生成：</h4><p>首先，我们修改主题配置文件：<br>&#x2F;&#x2F; 主题_config.yml 文件 ，搜索menu可找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home   #主页</span><br><span class="line">  about: /about/ || user  #关于</span><br><span class="line">  tags: /tags/ || tags   #标签</span><br><span class="line">  categories: /categories/ || th  #分类</span><br><span class="line">  archives: /archives/ || archive  #归档</span><br><span class="line">  #schedule: /schedule/ || calendar  #日程表</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap   #站点地图</span><br><span class="line">  #commonweal: /404/ || heartbeat    #公益404</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，大部分的都是注释掉了的，这里我已经把我需要的页面注释解除了，大家可以自行考虑需要的页面。<br>在这里，<strong>斜线&#x2F;&#x2F;<strong>之间的文字是 该页面 的名字，如／about／ ，说明我们要</strong>跳转的页面</strong>的名字为about , 而**||**后的文字是这个页面的图标名字.<br>这时候我们主页上就可以看到这几个页面，接下来实现页面的跳转：</p>
<h4 id="2-1-2-生成about页面："><a href="#2-1-2-生成about页面：" class="headerlink" title="2.1.2 生成about页面："></a>2.1.2 生成about页面：</h4><p>终端回到blog的根目录.运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ok,接下来<strong>关于</strong>页面的markdown自己编写就行。</p>
<h4 id="2-1-3-生成tags页面："><a href="#2-1-3-生成tags页面：" class="headerlink" title="2.1.3 生成tags页面："></a>2.1.3 生成tags页面：</h4><p>终端回到blog的根目录.运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-1-4-生成categories页面"><a href="#2-1-4-生成categories页面" class="headerlink" title="2.1.4 生成categories页面:"></a>2.1.4 生成categories页面:</h5><p>终端回到categories的根目录.运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tags和categorise页面不用自己布局，会自动根据我们的blog的布局好</p>
<h3 id="2-2-站内搜索功能的实现"><a href="#2-2-站内搜索功能的实现" class="headerlink" title="2.2 站内搜索功能的实现"></a>2.2 站内搜索功能的实现</h3><p>文章写多了，想一篇篇的去寻找可不容易，这时候，我们便需要一个站内的搜索功能，即服务别人，也能方便自己。<br>首先，我们在终端进入blog的根目录下，执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着，我们进入站点配置文件_config.yml,在最后新增以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，打开主题配置文件_config.yml,搜索local_search,其值改为true：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ok，现在站内搜索就大功告成了，一切准备就绪～</p>
<h3 id="2-3-个人头像设置"><a href="#2-3-个人头像设置" class="headerlink" title="2.3 个人头像设置"></a>2.3 个人头像设置</h3><p>要设置自己的侧边栏头像，首先，准备一张头像的图片，命名为<strong>header.jpg</strong>，然后，将图片放在<code>/blog/themes/next/source/images/</code>文件夹下，接着修改主题配置文件，搜索<code>avatar</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  # in theme directory(source/images): /images/avatar.gif</span><br><span class="line">  # in site  directory(source/uploads): /uploads/avatar.gif</span><br><span class="line">  # You can also use other linking images.</span><br><span class="line">   - url: /images/avatar.gif</span><br><span class="line">   + url: /images/header.jpg     #图片的地址</span><br><span class="line">  # If true, the avatar would be dispalyed in circle. </span><br><span class="line">  rounded: false   #设置图片是否为圆形，当图片为正方形时为圆，否则为椭圆</span><br><span class="line">  # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span><br><span class="line">  opacity: 1 #图片的透明度</span><br><span class="line">  # If true, the avatar would be rotated with the cursor.</span><br><span class="line">  rotated: false  #设置鼠标移到图片上后头像是否转动</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将<strong>url</strong>里面的值改为图片的地址就可以了，</p>
<h3 id="2-4-点击个人头像回到主页面"><a href="#2-4-点击个人头像回到主页面" class="headerlink" title="2.4 点击个人头像回到主页面"></a>2.4 点击个人头像回到主页面</h3><p>一般我们看到一个头像，总忍不住去点击它，然而遗憾的是，next主题中默认并没有这个事件，作为一个强迫症，这能忍？？？其实，实现这个功能也很简单：<br>首先，我们打开文件<code>/blog/themes/next/layout/_macro/sidebar.swig</code>,然后，修改以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ &lt;a href=&quot;/&quot;&gt;</span><br><span class="line">    &lt;img class=&quot;site-author-image&quot; itemprop=&quot;image&quot;</span><br><span class="line">       src=&quot;&#123;&#123; url_for( theme.avatar.url | default(theme.images + &#x27;/avatar.gif&#x27;) ) &#125;&#125;&quot;</span><br><span class="line">       alt=&quot;&#123;&#123; author &#125;&#125;&quot; /&gt;</span><br><span class="line">+ &lt;/a&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ok，重新部署一下，就可以看到效果了</p>
<h3 id="2-5-RSS订阅设置"><a href="#2-5-RSS订阅设置" class="headerlink" title="2.5 RSS订阅设置"></a>2.5 RSS订阅设置</h3><p>什么？大家都不知道什么是RSS？！！！<br>好吧，其实…本博主也不知道emmm，大家可以看看知乎上有关<a href="https://github.com/theme-next/hexo-theme-next/releases">RSS</a>的文章<br><del>PS：加上好看就完事了不是,计较干啥</del><br>首先，我们在终端命令行进入blog所在的目录，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-generator-feed</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着，打开<strong>站点配置文件</strong>，在文件的末尾添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: http://hexo.io/plugins/</span><br><span class="line">plugins: hexo-generate-feed</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后打开<strong>主题配置文件</strong>，搜索rss，将其设置成如下所示，注意冒号后要加上一个空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Set rss to false to disable feed link.</span><br><span class="line"># Leave rss as empty to use site&#x27;s feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`.</span><br><span class="line"># Set rss to specific value if you have burned your feed already.</span><br><span class="line">rss: /atom.xml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>OK，all right</p>
<h3 id="2-6-社交栏设置"><a href="#2-6-社交栏设置" class="headerlink" title="2.6 社交栏设置"></a>2.6 社交栏设置</h3><p>在主题配置文件中，搜索social，定位到如下代码段，把social的注释取消掉，接下来，就看你需要显示什么社交网站，写上网站名+网址就行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/yourname || github   #网站名：网址 ||图标名</span><br><span class="line">  简书: http://www.jianshu.com || heartbeat</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || envelope</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class="line">  #VK Group: https://vk.com/yourname || vk</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-7-增加网易云音乐"><a href="#2-7-增加网易云音乐" class="headerlink" title="2.7 增加网易云音乐"></a>2.7 增加网易云音乐</h3><p>音乐是不应该被辜负的，所以，我们可以在侧边栏加上网易云的音乐外链，具体方法为：</p>
<ol>
<li><p>打开网易云音乐网页版，选择自己想要放上去的音乐。</p>
</li>
<li><p>在播放页面选择外链播放器，选择一个自己喜欢的样式。<img src="http://pfv94oich.bkt.clouddn.com/friend%20A.png" alt="blog"></p>
</li>
<li><p>复制其中的代码<img src="http://pfv94oich.bkt.clouddn.com/friendA1.png" alt="blog"></p>
</li>
<li><p>打开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/blog/themes/next/layout/_macro/sidebar.swig</span><br></pre></td></tr></table></figure>

<p>文件，将代码复制到适合的位置，例如，我是在约161-162行增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% endif %&#125;</span><br><span class="line">         &#123;% include custom_sidebar %&#125;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">     &lt;/section&gt;</span><br><span class="line"></span><br><span class="line"> +  &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=5079881&amp;auto=0&amp;height=32&quot;&gt;&lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line">     &#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;</span><br><span class="line">     &lt;!--noindex--&gt;</span><br><span class="line">       &lt;section class=&quot;post-toc-wrap motion-element sidebar-panel sidebar-panel-active&quot;&gt;</span><br><span class="line">         &lt;div class=&quot;post-toc&quot;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>重新部署一下网站，就可以看到结果了</p>
<h3 id="2-8-实现侧边栏页面的圆角"><a href="#2-8-实现侧边栏页面的圆角" class="headerlink" title="2.8 实现侧边栏页面的圆角"></a>2.8 实现侧边栏页面的圆角</h3><p>侧边栏默认是矩形的，可能有一些朋友不是特别喜欢这种尖锐的四角，希望可以稍稍弄的平滑一点，说干就干！下面我们来具体实现它。</p>
<ol>
<li><p>首先，我们打开<code>/blog/themes/next/source/css/_variables/Pisces.styl</code>文件，里面定义了一些常量，用来定义blog样式表的值。</p>
</li>
<li><p>然后，找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$border-radius</span><br></pre></td></tr></table></figure>

<p>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Borders</span><br><span class="line">// --------------------------------------------------</span><br><span class="line">$box-shadow-inner                 = initial;</span><br><span class="line">$box-shadow                       = initial;</span><br><span class="line"></span><br><span class="line">$border-radius-inner              = initial;</span><br><span class="line">$border-radius                    = initial;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以看到默认为初始值，即为0<br>改变 为<code>$border-radius = 16px;</code><br>这时候，下面的一个侧边栏弧度就已经改好了</p>
<ol>
<li><p>接着，打开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/blog/themes/next/source/css/_schemes/Pisces/_layout.styl</span><br></pre></td></tr></table></figure>

<p>文件，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff:true.header-inner &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  padding: 0;</span><br><span class="line">  width: $sidebar-desktop;</span><br><span class="line">  background: white;</span><br><span class="line">  box-shadow: $box-shadow-inner;</span><br><span class="line"> -border-radius: $border-radius-inner;</span><br><span class="line"> +border-radius: $border-radius;//修改上面的侧边栏的弧度</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.content-wrap &#123;</span><br><span class="line">  float: right;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  padding: $content-desktop-padding;</span><br><span class="line">  width: $content-desktop;</span><br><span class="line">  background: white;</span><br><span class="line">  min-height: 700px;</span><br><span class="line">  box-shadow: $box-shadow-inner;</span><br><span class="line"> - border-radius: $border-radius-inner;</span><br><span class="line"> + border-radius: $border-radius; //修改整个文章页面的弧度</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ok 大功告成，到此为止，我们文章的侧边栏就已经优化完毕了，当然，还有更多操作，大家可以去尝试，不过，建议没有把握之前先做好blog的备份。<del>别问我为什么要这么说</del><br>来看看最终侧边栏效果：<br><img src="http://pfv94oich.bkt.clouddn.com/blog1.png" alt="blog"></p>
<h2 id="3-next主题主页面优化"><a href="#3-next主题主页面优化" class="headerlink" title="3. next主题主页面优化"></a>3. next主题主页面优化</h2><p>在上面我们已经把侧边栏的优化都已经完成了，不得不说，刚完成这一部分时我还是有很大的成就感的，接下来，我们将对我们blog的主页面进行进一步的优化。<br>在这一部分，我们将对以下进行操作：</p>
<ol>
<li>blog右上角出现fork me on github 图标</li>
<li>文章背景出现阴影边框</li>
<li>为文章内容添加统计功能，文字总数+阅读时长</li>
<li>为文章中的代码块增加一键复制功能</li>
<li>文章结尾出现“本文结束提示”</li>
<li>增加打赏功能</li>
<li>增加版权信息</li>
<li>修改标签样式</li>
</ol>
<h3 id="3-1-增加fork-me-on-github-图标"><a href="#3-1-增加fork-me-on-github-图标" class="headerlink" title="3.1 增加fork me on github 图标"></a>3.1 增加fork me on github 图标</h3><p>在<a href="http://tholman.com/github-corners/">这里</a>(图片版)或<a href="https://github.com/blog/273-github-ribbons">这里</a>(文字版)选择一款自己喜欢的图标，然后把图标旁的代码拷贝一份，放到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blog/themes/next/layout/_layout.swig</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个文件夹中，注意要放到<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下方<br>OK,这就大功告成了。</p>
<h3 id="3-2-文章背景出现阴影边框"><a href="#3-2-文章背景出现阴影边框" class="headerlink" title="3.2 文章背景出现阴影边框"></a>3.2 文章背景出现阴影边框</h3><p>这个效果实现起来很简单，打开<code>blog\themes\next\source\css\_custom\custom.styl</code>文件，放入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line"> .post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新部署一下即可实现。</p>
<h3 id="3-3-实现点击出现爱心功能"><a href="#3-3-实现点击出现爱心功能" class="headerlink" title="3.3 实现点击出现爱心功能"></a>3.3 实现点击出现爱心功能</h3><p>首先，进入<a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js">该网址</a>,复制页面中的代码，在路径<code>blog/themes/next/source/js/src/</code>中新建<code>love.js</code>文件，将复制的代码粘贴到该文件中。<br>然后打开<code>/blog/themes/next/layout/_layout.swig</code>文件，在该文件的最后增加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>保存后即可看到效果。</p>
<h3 id="3-4-“-阅读全文-”-按钮改弧度"><a href="#3-4-“-阅读全文-”-按钮改弧度" class="headerlink" title="3.4 “ 阅读全文 ” 按钮改弧度"></a>3.4 “ 阅读全文 ” 按钮改弧度</h3><p>这个功能和侧边栏改弧度的操作是差不多的，进入文件<code>/blog/themes/next/source/css/_variables/Pisces.styl</code>中，把以下代码修改一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Button</span><br><span class="line">- $btn-default-radius           = 2px</span><br><span class="line">+ $btn-default-radius           = 16px</span><br><span class="line">$btn-default-bg               = white</span><br><span class="line">$btn-default-color            = $text-color</span><br><span class="line">$btn-default-border-color     = $text-color</span><br><span class="line">$btn-default-hover-color      = white</span><br><span class="line">$btn-default-hover-bg         = $black-deep</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>保存后即可看见效果。</p>
<h3 id="3-5-为文章内容添加统计功能，文字总数-阅读时长"><a href="#3-5-为文章内容添加统计功能，文字总数-阅读时长" class="headerlink" title="3.5 为文章内容添加统计功能，文字总数+阅读时长"></a>3.5 为文章内容添加统计功能，文字总数+阅读时长</h3><p>这个功能在next主题中已经存在了，我们只需要打开开关就行，具体步骤分为下面三步：</p>
<ol>
<li><p>终端进入blog根目录，执行下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>进入站点配置文件，为blog配置统计功能，将以下代码复制到最后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>进入主题配置文件，搜素<code>symbols_count_time</code>,然后把要显示的改为<code>true</code>.<br>更深入的操作大家可以看github上的<a href="https://github.com/theme-next/hexo-symbols-count-time">说明</a>。<br>PS：如果大家配置完成，然后检查无误后，打开页面依旧没有显示，不要着急，第一次显示可能会比较慢，可以休息一会。（本人多次从头配置都没有效果，一气之下去睡了个午觉，醒来就好了0.0）.</p>
</li>
</ol>
<h3 id="3-6-为文章中的代码块增加一键复制功能"><a href="#3-6-为文章中的代码块增加一键复制功能" class="headerlink" title="3.6 为文章中的代码块增加一键复制功能"></a>3.6 为文章中的代码块增加一键复制功能</h3><p>在next v6.3.0 版本中，这个功能已经是集成了的，我们进入站点配置文件，搜索<code>copy_button</code>。把它的值改为true即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Add copy button on codeblock</span><br><span class="line">  copy_button:copy</span><br><span class="line">    enable: true  #是否开启复制功能</span><br><span class="line">    # Show text copy result</span><br><span class="line">    show_result: true #是否显示提示的复制结果</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着，将鼠标移动到代码块中，便可以看到结果。默认按钮是中文“复制”，若是想改为英文“copy”，可进入<code>blog/themes/next/languages/zh-CN.yml</code>文件中，将下面部分改了即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy_button: copy</span><br><span class="line">copy_success: succeed</span><br><span class="line">copy_failure: failed</span><br><span class="line">copyright:</span><br><span class="line">   author: 本文作者</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个文件夹中保留了所有的中英部分的对应关系，大家想改各标签名字的话，可以将这个文件中对应的部分改了即可。</p>
<h3 id="3-7-文章结尾提示-“本文结束”"><a href="#3-7-文章结尾提示-“本文结束”" class="headerlink" title="3.7 文章结尾提示 “本文结束”"></a>3.7 文章结尾提示 “本文结束”</h3><p>在文件夹<code>\themes\next\layout\_macro</code>中新建<code>passage-end-tag.swig</code>文件，并在文件中增加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #555;font-size:14px;&quot;&gt;-------------The End-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，再这个地方增加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &#123;#####################&#125;</span><br><span class="line"> &#123;### END POST BODY ###&#125;</span><br><span class="line"> &#123;#####################&#125;</span><br><span class="line"></span><br><span class="line">+ &lt;div&gt;</span><br><span class="line">+  &#123;% if not is_index %&#125;</span><br><span class="line">+    &#123;% include &#x27;passage-end-tag.swig&#x27; %&#125;</span><br><span class="line">+  &#123;% endif %&#125;</span><br><span class="line">+ &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"> &#123;% if theme.wechat_subscriber.enabled and not is_index %&#125;</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     &#123;% include &#x27;wechat-subscriber.swig&#x27; %&#125;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"> &#123;% endif %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &#x27;passage-end-tag.swig&#x27; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后打开主题配置文件，在文件的最后增加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>保存后，打开网页即可看到效果。</p>
<h3 id="3-8-增加打赏功能"><a href="#3-8-增加打赏功能" class="headerlink" title="3.8 增加打赏功能"></a>3.8 增加打赏功能</h3><p>这个功能很简单，首先，我们将保存微信支付的收款码，将其命名为<code>wechatpay.jpg</code>，并将其保存在<code>/blog/themes/next/source/images/</code>文件中。<br>接着，我们打开主题配置文件，搜索<code>wechatpay</code>，将其前面的注释取消即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Reward</span><br><span class="line">#reward_comment: Donate comment here</span><br><span class="line">wechatpay: /images/wechatpay.jpg</span><br><span class="line">#alipay: /images/alipay.jpg</span><br><span class="line">#bitcoin: /images/bitcoin.png</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们可以放多种方式的支付码，看个人喜好即可，方法都是一样的。</p>
<h3 id="3-9-增加版权信息"><a href="#3-9-增加版权信息" class="headerlink" title="3.9 增加版权信息"></a>3.9 增加版权信息</h3><p>博文写好了，怎么说也是作者的一番心血，我们不去抄袭别人的作品，也不希望别人什么都不说带走我们的作品，所以，我们需要在底部做一个版权申明：<br>next主题中现在已经是集成了这个功能的了，我们只在主题配置文件中搜索<code>copyright</code>,并把<code>enable</code>的值改为<code>true</code>即可.</p>
<h3 id="3-10-修改标签样式"><a href="#3-10-修改标签样式" class="headerlink" title="3.10 修改标签样式"></a>3.10 修改标签样式</h3><p>默认的标签前面是一个#号，我们把它改成标签的符号：<br>修改模板<code>/themes/next/layout/\_macro/post.swig</code>，搜索<code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>即可。</p>
<p>这时候，我们的标签还是有下划线的，要想去掉下滑线，我们可以进入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/blog/themes/next/source/css/_custom/custom.styl</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>文件，在文件最后增加下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.posts-expand .post-tags a &#123;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>即可</p>
<hr>
<h2 id="4-next主题底部优化"><a href="#4-next主题底部优化" class="headerlink" title="4. next主题底部优化"></a>4. next主题底部优化</h2><p>侧边栏和主页面的优化都已经实现了，接下来便是底部部分的优化，主要包括下面几个部分：</p>
<ol>
<li>为文章增加评论功能</li>
<li>增加在线联系Daovoice</li>
<li>修改底部作者图标为跳动的红心</li>
<li>隐藏下方的强力驱动和主题信息</li>
<li>增加本站运行时间</li>
<li>增加站点访问人数和总访问量</li>
</ol>
<h3 id="4-1-为文章增加评论功能"><a href="#4-1-为文章增加评论功能" class="headerlink" title="4.1 为文章增加评论功能"></a>4.1 为文章增加评论功能</h3><p>next主题的6.x版里面已经集成了很多评论了，包括Gitment和Valine，大家有兴趣可以去试一试。<br>最开始我用的评论是来必力评论系统，</p>
<h3 id="4-2-增加在线联系Daovoice"><a href="#4-2-增加在线联系Daovoice" class="headerlink" title="4.2 增加在线联系Daovoice"></a>4.2 增加在线联系Daovoice</h3><p>首先在<a href="http://dashboard.daovoice.io/get-started?invite_code=5f355066">Daovoice</a>注册账号,邀请码是<code>5f353066</code>，注册完成后会得到一个 app_id<br>声明：这个链接包含了博主的邀请码，注册成功每人会有100元代金券，如果不想使用，可以进入<a href="https://account.daocloud.io/signin">Daovoice官网</a>注册账号。<br>注册成功后，会得到一个app_id:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daovoice(&#x27;init&#x27;, &#123;</span><br><span class="line">  app_id: &quot;*******&quot;</span><br><span class="line">&#125;);</span><br><span class="line">daovoice(&#x27;update&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>记下这个app_id的值，然后打开<code>/blog/themes/next/layout/_partials/head/head.swig</code>文件，在如下位置插入代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.daovoice %&#125;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&#x27;https:&#x27; == document.location.protocol ? &#x27;https:&#x27; : &#x27;http:&#x27;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;)</span><br><span class="line">  daovoice(&#x27;init&#x27;, &#123;</span><br><span class="line">      app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">  daovoice(&#x27;update&#x27;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着打开主题配置文件，在最后写下如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Online contact </span><br><span class="line">daovoice: true</span><br><span class="line">daovoice_app_id: 这里填你的刚才获得的 app_id</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>保存后打开页面即可看见效果。</p>
<h3 id="4-3-修改底部作者图标为跳动的红心"><a href="#4-3-修改底部作者图标为跳动的红心" class="headerlink" title="4.3 修改底部作者图标为跳动的红心"></a>4.3 修改底部作者图标为跳动的红心</h3><p>这个功能实现起来很简单，打开主题配置文件,搜索<code>animated</code>:<br>把<code>icon</code> 区域的代码做如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Icon between year and copyright info.</span><br><span class="line"> icon:</span><br><span class="line">   # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons</span><br><span class="line">   # `heart` is recommended with animation in red (#ff0000).</span><br><span class="line">   name: heart</span><br><span class="line">   # If you want to animate the icon, set it to true.</span><br><span class="line">   animated: true</span><br><span class="line">   # Change the color of icon, using Hex Code.</span><br><span class="line">   color: &quot;#ff0000&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>保存即可，如果想改为其他的图标，进入网站修改即可</p>
<h3 id="4-4-隐藏下方的强力驱动和主题信息"><a href="#4-4-隐藏下方的强力驱动和主题信息" class="headerlink" title="4.4 隐藏下方的强力驱动和主题信息"></a>4.4 隐藏下方的强力驱动和主题信息</h3><p>进入<code>/blog/themes/next/layout/_partials/footer.swig</code>文件，注释掉关于这部分的信息即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.footer.powered.enable %&#125;</span><br><span class="line"> + &lt;!-- </span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&#x27;footer.powered&#x27;, &#x27;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&#x27; + nofollow + &#x27; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&#x27;) &#125;&#125;&#123;% if theme.footer.powered.version %&#125; v&#123;&#123; hexo_env(&#x27;version&#x27;) &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.powered.enable and theme.footer.theme.enable %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.theme.enable %&#125;</span><br><span class="line">  &lt;div class=&quot;theme-info&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&#x27;footer.theme&#x27;) &#125;&#125; &amp;mdash; &#123;#</span><br><span class="line">  #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot;&#123;&#123; nofollow &#125;&#125; href=&quot;https://github.com/theme-next/hexo-theme-next&quot;&gt;&#123;#</span><br><span class="line">    #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;#</span><br><span class="line">  #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; version &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line">+ --&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-5-增加本站运行时间"><a href="#4-5-增加本站运行时间" class="headerlink" title="4.5 增加本站运行时间"></a>4.5 增加本站运行时间</h3><p>进入<code>/blog/themes/next/layout/_partials/footer.swig</code>文件，在文件合适的地方放上如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;days&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function show_date_time()&#123;</span><br><span class="line">    window.setTimeout(&quot;show_date_time()&quot;, 1000);</span><br><span class="line">    BirthDay=new Date(&quot;04/17/2018 15:13:14&quot;);//修改为自己的blog建站时间</span><br><span class="line">    today=new Date();</span><br><span class="line">    timeold=(today.getTime()-BirthDay.getTime());</span><br><span class="line">    sectimeold=timeold/1000</span><br><span class="line">    secondsold=Math.floor(sectimeold);</span><br><span class="line">    msPerDay=24*60*60*1000</span><br><span class="line">    e_daysold=timeold/msPerDay</span><br><span class="line">    daysold=Math.floor(e_daysold);</span><br><span class="line">    e_hrsold=(e_daysold-daysold)*24;</span><br><span class="line">    hrsold=setzero(Math.floor(e_hrsold));</span><br><span class="line">    e_minsold=(e_hrsold-hrsold)*60;</span><br><span class="line">    minsold=setzero(Math.floor((e_hrsold-hrsold)*60));</span><br><span class="line">    seconds=setzero(Math.floor((e_minsold-minsold)*60));</span><br><span class="line">    document.getElementById(&#x27;days&#x27;).innerHTML=&quot;本站已安全运行&quot;+daysold+&quot;天&quot;+hrsold+&quot;小时&quot;+minsold+&quot;分&quot;+seconds+&quot;秒&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function setzero(i)&#123;</span><br><span class="line">    if (i&lt;10)</span><br><span class="line">    &#123;i=&quot;0&quot; + i&#125;;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line">show_date_time();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如我是在原next主题版本信息的下方增加上面的代码，代码在不同的位置会有不同的效果。</p>
<h3 id="4-6-增加站点访问人数和总访问量"><a href="#4-6-增加站点访问人数和总访问量" class="headerlink" title="4.6 增加站点访问人数和总访问量"></a>4.6 增加站点访问人数和总访问量</h3><p>打开主题配置文件，搜索busuanzi，将<code>enable</code>的值改为<code>true</code>即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-推荐大佬文章"><a href="#5-推荐大佬文章" class="headerlink" title="5. 推荐大佬文章"></a>5. 推荐大佬文章</h2><p>这篇文章主要是为了记录自己搭建blog的经历，因为搭建blog的时候，自己经常忘记优化的方法，特记下以减轻今后搜索的负担：<br>网上有很多特别详细的优化文章，本篇文章也参考了很多，特拿出来与大家分享：</p>
<ol>
<li><a href="https://cherryblog.site/Hexo-high-level-tutorialcloudmusic,bg-customthemes-statistical.html">hexo高阶教程next主题优化</a></li>
<li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html">hexo的next主题个性化教程:打造炫酷网站</a></li>
<li><a href="https://www.dingxuewen.com/categories/Site/">Hexo搭建博客的个性化设置</a></li>
<li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></li>
</ol>
<p><strong>强烈推荐最后一篇blog，一路看下来会收获很多很多</strong></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于mybatis分页工具异常的解决办法</title>
    <url>/2025/08/06/%E5%85%B3%E4%BA%8Emybatis%E5%88%86%E9%A1%B5%E5%B7%A5%E5%85%B7%E5%BC%82%E5%B8%B8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p><em>异常名称：</em> <em><strong>Could not find method oninterface org.apache.ibatis.executor.statement.</strong></em></p>
<p><strong>引起异常的原因：</strong></p>
<p>在PagePlugins.java的代码中：</p>
<p>3.4.0之前分页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Intercepts(value =&#123;@Signature(type = StatementHandler.class, method = &quot;prepare&quot;,args = &#123;Connection.class&#125;)&#125;) //3.40之前的写法</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>3.4.0之后分页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Intercepts(value = &#123;@Signature(type = StatementHandler.class, method = &quot;prepare&quot;,</span><br><span class="line"> args = &#123;Connection.class,Integer.class&#125;)&#125;)  //3.40之后的写法</span><br></pre></td></tr></table></figure>

<p><strong>多了一个Interger.class的参数</strong></p>
<p>原链接：<a href="http://www.cnblogs.com/EasonJim/p/7056700.html">http://www.cnblogs.com/EasonJim/p/7056700.html</a></p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title>创建微服务工程步骤</title>
    <url>/2025/08/06/microservice/</url>
    <content><![CDATA[<p>构建步骤：</p>
<h4 id="整体父工程Project："><a href="#整体父工程Project：" class="headerlink" title="整体父工程Project："></a>整体父工程Project：</h4><ul>
<li><p><em><strong>新建父工程microservicecloud，切记Packaging是pom模式，如下图所示：</strong></em></p>
<img src="/2025/08/06/microservice/pom.PNG" class="" title="说明">
</li>
<li><p>主要定义POM文件，将后续各个子模块公用的jar包等统一提出来，类似一个抽象父类</p>
</li>
<li><p>POM</p>
<p>pom文件如图所示：</p>
<span id="more"></span>

<img src="/2025/08/06/microservice/pom1.PNG" class="" title="说明">

<img src="/2025/08/06/microservice/pom2.PNG" class="" title="说明">

<img src="/2025/08/06/microservice/pom3.PNG" class="" title="说明">

<img src="/2025/08/06/microservice/pom4.PNG" class="" title="说明">

<h4 id="公共子模块Module："><a href="#公共子模块Module：" class="headerlink" title="公共子模块Module："></a>公共子模块Module：</h4></li>
<li><p>新建microservicecloud-api</p>
<p><strong>注意此工程要在父工程下创建，如图所示：</strong></p>
<img src="/2025/08/06/microservice/maven_module.PNG" class="" title="说明">

<p>创建完成后回到父工程查看pom文件的变化</p>
</li>
<li><p>修改POM</p>
<img src="/2025/08/06/microservice/edit_mudole_pom.PNG" class="" title="说明">
</li>
<li><p>新建部门Entity且配合lombok使用</p>
<p>下图为lombok具体使用：</p>
<img src="/2025/08/06/microservice/lombok_application.PNG" class="" title="说明">
</li>
<li><p>mvn clean install后其他模块引用，达到通用目的，也即需要用到部门实体的话，不用每个工程都定义一份，直接引用本模块即可。</p>
<h4 id="部门微服务提供者Module："><a href="#部门微服务提供者Module：" class="headerlink" title="部门微服务提供者Module："></a>部门微服务提供者Module：</h4><p>开发步骤如下图所示：</p>
<img src="/2025/08/06/microservice/develop_process.PNG" class="" title="说明">

<p><strong>其中spring.application.name的配置很重要</strong>，如下图所示：</p>
<img src="/2025/08/06/microservice/application_name.PNG" class="" title="说明">

<p>最终的微服务的工程展现图如下图所示：</p>
<img src="/2025/08/06/microservice/final_view.PNG" class="" title="说明">

<h4 id="部门微服务消费者Module："><a href="#部门微服务消费者Module：" class="headerlink" title="部门微服务消费者Module："></a>部门微服务消费者Module：</h4></li>
</ul>
]]></content>
      <categories>
        <category>项目心得</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Maven工程</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
</search>
